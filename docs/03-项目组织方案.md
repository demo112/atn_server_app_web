# 项目组织方案

## 一、仓库结构

### 结论：Monorepo (单仓库)

采用 **pnpm workspace** 管理 Monorepo。

| 层面 | 方案 | 说明 |
|------|------|------|
| **物理** | 单仓库 | 所有代码在同一个 Git 仓库中管理 |
| **逻辑** | 模块化 | 通过 packages 拆分，利用 workspace 协议管理依赖 |
| **依赖管理** | pnpm | 利用 pnpm 的硬链接机制节省空间，提升安装速度 |

---

## 二、多端关系与依赖规则

### 逻辑隔离
**核心原则**：模块之间有清晰的边界和依赖规则，严禁越界引用。

### 依赖方向
```
server ──→ shared ←── web
              ↑
             app
```

*   **shared**: 被所有模块依赖，**绝不**依赖其他业务模块。
*   **server**: 仅依赖 shared，**不可**引用 web/app。
*   **web**: 仅依赖 shared，**不可**引用 server/app。
*   **app**: 仅依赖 shared，**不可**引用 server/web。

---

## 三、目录结构

### 整体结构
```
attendance-system/
├── package.json          # 根配置，定义 workspaces
├── pnpm-workspace.yaml   # pnpm workspace 配置
├── tsconfig.json         # 全局 TS 配置，定义路径映射
├── packages/
│   ├── shared/           # 公共类型、工具函数、常量
│   ├── server/           # 后端服务 (Node.js/Python等)
│   ├── web/              # Web 前端 (React/Vue等)
│   └── app/              # 移动端 (React Native/Flutter等)
└── docs/                 # 项目文档
```

### Server 结构
(待填充详细技术栈结构)

### App 结构
(待填充详细技术栈结构)

### Web 结构
(待填充详细技术栈结构)

---

## 四、AI编码友好设计

### 1. 明确的模块边界
通过 `package.json` 的 `dependencies` 显式声明依赖，帮助 AI 理解模块关系。
例如：`import { User } from '@attendance/shared'` 清晰表明来源。

### 2. 统一的路径映射
使用 TypeScript `paths` 配置，让 AI 在生成代码时使用标准别名，而非脆弱的相对路径（如 `../../shared`）。

### 3. 规范的命名
*   包名统一前缀：`@attendance/*`
*   目录名与包名对应：`packages/server` -> `@attendance/server`

---

## 五、版本管理

### Git 工作流
*   主分支：`main` / `master`
*   开发分支：`develop`
*   功能分支：`feature/*`

### 分支策略
*   所有新功能开发基于 `develop` 分支切出。
*   提交前必须通过 Lint 检查。

---

## 六、2人协作方式

### 分工
*   一人主攻 Server + Shared 定义
*   一人主攻 Web/App + Shared 消费
*   Shared 层的变更需双方确认（或 Code Review）

### 冲突处理
*   利用 Git 进行合并。
*   Monorepo 优势：原子性提交，Shared 变更和业务代码变更在同一次 Commit 中，减少版本不一致导致的冲突。
