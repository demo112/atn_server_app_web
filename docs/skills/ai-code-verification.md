# AI 代码验证系统

> 纯 AI 编码场景下的多重验证系统，不依赖人类编码能力判断代码正确性。

## 核心理念

**单一验证不可信，多重独立验证提升可信度。**

在人类无法判断代码正确性的场景下，测试的作用不是"验证正确"，而是：
- 形式化需求（把模糊变清晰）
- 自洽性检查（内部逻辑一致）
- 变更保护（修改不破坏已有行为）
- 边界探索（发现没想到的情况）

## 激活方式

以下场景自动启动：
- 需要验证 AI 生成的代码
- 编写测试用例
- 代码质量评估
- 功能开发完成后的验收

触发关键词：验证、测试、质量保障、代码审查、可信度

## 四维验证框架

```
┌─────────────────────────────────────────────────────┐
│                    可信度评估                        │
├─────────────────────────────────────────────────────┤
│  维度1        维度2        维度3        维度4        │
│  契约验证     自洽性验证    对抗性验证    交叉验证     │
│  Contract    Consistency  Adversarial  Cross-check │
└─────────────────────────────────────────────────────┘
```

---

## 维度1：契约验证（Contract）

### 目的
把模糊的需求变成可执行的形式化规格。

### 核心问题
不是问"这个输入得到这个输出对不对"，而是问"输入输出之间的关系满足什么约束"。

### 契约类型

| 类型 | 描述 | 示例 |
|------|------|------|
| 往返属性 | 操作后逆操作恢复原值 | `decode(encode(x)) === x` |
| 不变性质 | 操作前后某些性质不变 | `sort(list).length === list.length` |
| 幂等性 | 多次执行结果相同 | `abs(abs(x)) === abs(x)` |
| 单调性 | 输入增大输出不减小 | `x > y → f(x) >= f(y)` |
| 前置/后置条件 | 输入约束和输出保证 | `输入 > 0 → 输出 > 0` |

### 操作步骤

**Step 1: 从需求提取契约**
```
需求：用户注册功能，邮箱不能重复

契约：
- 前置条件：邮箱格式合法
- 后置条件：注册成功 → 数据库中存在该用户
- 不变性质：注册前后，其他用户数据不变
- 幂等性：相同邮箱重复注册 → 返回相同错误
```

**Step 2: 用属性测试验证契约**
```typescript
import fc from 'fast-check';

// 契约：邮箱格式合法 → 注册成功或返回"已存在"
fc.assert(
  fc.property(fc.emailAddress(), async (email) => {
    const result = await register(email);
    return result.success || result.error === 'EMAIL_EXISTS';
  })
);
```

### 输出格式
```markdown
## 契约定义报告

### 功能：[功能名称]

### 提取的契约

| 契约类型 | 形式化描述 | 验证状态 |
|----------|-----------|----------|
| 前置条件 | `email.isValid()` | ✅ 已验证 |
| 后置条件 | `db.exists(user)` | ✅ 已验证 |
| 不变性质 | `otherUsers.unchanged()` | ⚠️ 未验证 |

### 属性测试代码
[生成的测试代码]
```

---

## 维度2：自洽性验证（Consistency）

### 目的
确保代码内部逻辑一致，不自相矛盾。

### 验证手段

| 手段 | 作用 | 工具 |
|------|------|------|
| 类型系统 | 编译时捕获类型错误 | TypeScript strict mode |
| 运行时断言 | 关键位置检查不变量 | assert / invariant |
| 状态机约束 | 确保状态转换合法 | XState / 自定义 |
| 依赖规则 | 确保模块边界清晰 | ESLint import rules |

### 操作步骤

**Step 1: 启用严格类型检查**
```json
// tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
```

**Step 2: 关键位置插入断言**
```typescript
function processOrder(order: Order): void {
  // 前置条件断言
  invariant(order.status === 'pending', 'Order must be pending');
  
  // 业务逻辑
  order.status = 'processing';
  
  // 后置条件断言
  invariant(order.status === 'processing', 'Order must be processing after');
}
```

**Step 3: 定义状态机约束**
```typescript
const orderStateMachine = {
  states: ['pending', 'paid', 'shipped', 'completed', 'cancelled'],
  transitions: {
    pending: ['paid', 'cancelled'],
    paid: ['shipped', 'cancelled'],
    shipped: ['completed'],
    completed: [],
    cancelled: []
  }
};

function validateTransition(from: string, to: string): boolean {
  return orderStateMachine.transitions[from]?.includes(to) ?? false;
}
```

### 输出格式
```markdown
## 自洽性检查报告

### 类型检查
- 错误数：0
- 警告数：2
- 状态：✅ 通过

### 断言覆盖
- 关键函数数：15
- 已添加断言：12
- 覆盖率：80%

### 状态机验证
- 定义的状态：5
- 合法转换：8
- 非法转换测试：✅ 全部阻止
```

---

## 维度3：对抗性验证（Adversarial）

### 目的
故意尝试破坏代码，如果代码能抵抗攻击，可信度更高。

### 攻击类型

| 攻击类型 | 描述 | 工具 |
|----------|------|------|
| 模糊测试 | 随机/畸形输入 | fast-check / Hypothesis |
| 变异测试 | 故意改错代码看测试能否发现 | Stryker / mutmut |
| 边界攻击 | 极端值、空值、超大数据 | 自定义生成器 |
| 并发攻击 | 竞态条件、重复提交 | 并发测试框架 |

### 操作步骤

**Step 1: 模糊测试**
```typescript
// 用随机输入攻击函数
fc.assert(
  fc.property(
    fc.anything(), // 任意输入
    (input) => {
      try {
        const result = targetFunction(input);
        // 不应该抛出未处理的异常
        return true;
      } catch (e) {
        // 只允许预期的业务异常
        return e instanceof BusinessError;
      }
    }
  )
);
```

**Step 2: 变异测试**
```bash
# 运行变异测试
npx stryker run

# 分析存活的变异体 = 测试盲区
```

**Step 3: 边界攻击**
```typescript
const boundaryInputs = fc.oneof(
  fc.constant(null),
  fc.constant(undefined),
  fc.constant(''),
  fc.constant([]),
  fc.constant({}),
  fc.constant(Number.MAX_SAFE_INTEGER),
  fc.constant(Number.MIN_SAFE_INTEGER),
  fc.constant(Number.NaN),
  fc.constant(Infinity),
  fc.string({ minLength: 10000 }), // 超长字符串
);
```

### 输出格式
```markdown
## 对抗性测试报告

### 模糊测试
- 执行次数：10000
- 发现问题：2
- 问题详情：
  1. 输入 `null` 时抛出 TypeError
  2. 输入超长字符串时性能下降

### 变异测试
- 变异体总数：150
- 被杀死：135
- 存活：15
- **变异覆盖率：90%**

### 存活变异体分析
| 位置 | 变异 | 风险 |
|------|------|------|
| line 42 | `>` → `>=` | 🔴 高 |
| line 78 | `+1` → `+2` | 🟡 中 |
```

---

## 维度4：交叉验证（Cross-validation）

### 目的
用多个独立视角验证，发现理解偏差。

### 核心思想
```
可信度 = f(独立验证数量, 验证间一致性)
```

如果多个独立的分析得出相同结论，可信度更高。

### 验证方式

| 方式 | 描述 |
|------|------|
| 需求重述 | 用不同方式重新描述需求，检查是否一致 |
| 代码审查 | 独立审查代码，不看原始思路 |
| 测试独立编写 | 只看需求写测试，不看实现 |
| 反向推导 | 从代码反推需求，与原需求对比 |

### 操作步骤

**Step 1: 需求重述验证**
```markdown
原始需求：用户注册时邮箱不能重复

重述1：系统应拒绝使用已存在邮箱的注册请求
重述2：每个邮箱地址只能关联一个用户账户
重述3：注册接口在邮箱已被使用时返回错误

一致性检查：✅ 三种重述语义一致
```

**Step 2: 代码-需求一致性检查**
```markdown
需求点：邮箱不能重复
代码实现：
- ✅ 注册前查询邮箱是否存在
- ✅ 存在时返回错误
- ⚠️ 未处理并发注册场景（两个请求同时检查都不存在）

发现分歧：并发场景未覆盖
```

**Step 3: 测试-实现独立性检查**
```markdown
测试编写者视角（只看需求）：
- 测试1：新邮箱注册成功
- 测试2：重复邮箱注册失败
- 测试3：邮箱格式错误时注册失败

实现者视角（看代码）：
- 实现了邮箱查重
- 实现了格式校验
- 未实现并发控制

交叉对比：测试未覆盖并发，实现也未处理 → 风险点
```

### 输出格式
```markdown
## 交叉验证报告

### 一致性评分：85/100

### 验证结果

| 验证维度 | 结果 | 说明 |
|----------|------|------|
| 需求重述 | ✅ 一致 | 三种重述语义相同 |
| 代码-需求 | ⚠️ 部分一致 | 并发场景未覆盖 |
| 测试-实现 | ⚠️ 部分一致 | 测试和实现都遗漏并发 |

### 发现的分歧点
1. **并发注册场景** - 需求未明确，实现未处理，测试未覆盖
   - 建议：与需求方确认是否需要处理
   - 风险等级：🟡 中

### 人类决策点
以下问题需要人类判断：
- [ ] 是否需要处理并发注册？
- [ ] 邮箱大小写是否敏感？
```

---

## 完整工作流程

```
┌─────────────────────────────────────────────────────┐
│ 1. 需求输入                                          │
│    ↓                                                │
│ 2. 契约定义（维度1）                                  │
│    - 提取属性、不变量、前后置条件                      │
│    ↓                                                │
│ 3. 代码实现                                          │
│    - 满足契约                                        │
│    - 插入断言（维度2）                                │
│    ↓                                                │
│ 4. 对抗性测试（维度3）                                │
│    - 模糊测试                                        │
│    - 变异测试                                        │
│    ↓                                                │
│ 5. 交叉验证（维度4）                                  │
│    - 多视角检查一致性                                 │
│    ↓                                                │
│ 6. 输出可信度报告                                     │
│    - 综合评分                                        │
│    - 风险标记                                        │
│    - 人类决策点                                      │
└─────────────────────────────────────────────────────┘
```

---

## 可信度评分标准

| 维度 | 权重 | 评分标准 |
|------|------|----------|
| 契约验证 | 30% | 契约覆盖率 × 属性测试通过率 |
| 自洽性验证 | 20% | 类型检查通过 + 断言覆盖率 |
| 对抗性验证 | 30% | 变异覆盖率 × 模糊测试存活率 |
| 交叉验证 | 20% | 多视角一致性评分 |

### 评分等级

| 等级 | 分数 | 含义 |
|------|------|------|
| A | 90-100 | 高可信度，可放心使用 |
| B | 80-89 | 良好，存在小风险 |
| C | 70-79 | 一般，需关注风险点 |
| D | 60-69 | 较低，建议补充验证 |
| F | <60 | 不可信，需重新验证 |

---

## 输出模板

```markdown
# [功能名称] 验证报告

## 综合评分：[等级] ([分数]/100)

## 各维度评分

| 维度 | 得分 | 状态 |
|------|------|------|
| 契约验证 | 85 | ✅ |
| 自洽性验证 | 90 | ✅ |
| 对抗性验证 | 75 | ⚠️ |
| 交叉验证 | 80 | ✅ |

## 风险点

### 🔴 高风险
- [风险描述]

### 🟡 中风险
- [风险描述]

## 人类决策点

以下问题需要人类判断：
- [ ] [问题1]
- [ ] [问题2]

## 建议行动

1. [行动1]
2. [行动2]
```

---

## 与项目的集成

### 在开发流程中的位置

```
需求确认 → 契约定义 → 编码 → 验证 → 人类决策 → 合并
              ↑                    ↓
              └──── 发现问题返工 ←──┘
```

### 人类的角色

人类不需要判断代码对不对，只需要：
1. **确认需求理解** - 契约是否正确表达了需求
2. **在分歧点决策** - 当多视角理解不一致时做选择
3. **接受风险** - 了解风险点后决定是否继续

### 触发时机

- 功能开发完成后
- 代码审查时
- 发布前质量检查
- 发现 Bug 后的根因分析
