# 协作方式讨论记录

## 讨论背景

2人团队，时间紧张，需要确定最高效的协作方式。

---

## 关键认知转变

### 传统开发 vs AI编码

| 传统开发 | AI编码 |
|---------|--------|
| 人A写代码 ←→ 人B写代码 | 人A指挥AI ←→ 人B指挥AI |
| 人是执行者 | 人是指挥官 |
| 分工是"谁写哪部分代码" | 分工是"谁指挥AI完成哪个功能" |

---

## 分工模式对比

### 按端分工（水平切分）

```
A: 整个 server 层
B: 整个 web/app 层
```

**问题：** 存在串行等待（B要等A的API才能对接）

### 按功能分工（垂直切分）

```
A: 用户模块（server + web + app 全部）
B: 考勤模块（server + web + app 全部）
```

**优势：** 完全并行，无等待

---

## 最终方案

### 功能垂直切分 + 命名空间隔离

**分工：**
- 人A 指挥AI完成"用户模块"
- 人B 指挥AI完成"考勤模块"

**隔离规则：**

| 维度 | A（用户模块） | B（考勤模块） |
|------|--------------|--------------|
| API路径 | `/api/v1/user/*` | `/api/v1/attendance/*` |
| 数据库表 | `users`, `user_*` | `attendance_*`, `shifts` |
| 类型前缀 | `User*`, `Auth*` | `Attendance*`, `Clock*` |
| 目录 | `*/user/` | `*/attendance/` |

**目的：** 两个AI会话生成的代码不重叠，合并时不冲突。

---

## AI约束实现

通过 `user_rules.md` 声明各自负责的模块：

**A 的配置：**
```markdown
我负责用户模块（user）
- 模块名：user
- 类型前缀：User
- API路径：/api/v1/user/*
- 只能操作 */user/* 目录下的文件
```

**B 的配置：**
```markdown
我负责考勤模块（attendance）
- 模块名：attendance
- 类型前缀：Attendance
- API路径：/api/v1/attendance/*
- 只能操作 */attendance/* 目录下的文件
```

---

## 工作流程

### 第一阶段：共同搭建基础（1-2天）

两人一起：
- 确定技术栈
- 定义共享类型（common.ts）
- 设计数据库表结构
- 配置 Rules/Skills

### 第二阶段：并行开发

各自独立工作，指挥AI完成负责的模块。
完全并行，无需等待对方。

### 第三阶段：集成联调

两人一起：
- 功能串联
- 联调测试
- 问题修复

---

## 效率优势

| 优势 | 说明 |
|------|------|
| 无阻塞 | 不需要等对方完成 |
| 无冲突 | 命名空间隔离 |
| 责任清晰 | 一个功能出问题找对应的人 |
| AI友好 | 每次只让AI关注一个功能模块 |
