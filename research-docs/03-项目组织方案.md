# 项目组织方案

## 一、仓库结构

### 结论：Monorepo (单仓库)

采用 **pnpm workspace** 管理 Monorepo。

| 层面 | 方案 | 说明 |
|------|------|------|
| **物理** | 单仓库 | 所有代码在同一个 Git 仓库中管理 |
| **逻辑** | 模块化 | 通过 packages 拆分，利用 workspace 协议管理依赖 |
| **依赖管理** | pnpm | 利用 pnpm 的硬链接机制节省空间，提升安装速度 |

---

## 二、多端关系与依赖规则

### 逻辑隔离
**核心原则**：模块之间有清晰的边界和依赖规则，严禁越界引用。

### 依赖方向
```
server ──→ shared ←── web
              ↑
             app
```

*   **shared**: 被所有模块依赖，**绝不**依赖其他业务模块。
*   **server**: 仅依赖 shared，**不可**引用 web/app。
*   **web**: 仅依赖 shared，**不可**引用 server/app。
*   **app**: 仅依赖 shared，**不可**引用 server/web。

---

## 三、目录结构

### 整体结构
```
attendance-system/
├── package.json          # 根配置，定义 workspaces
├── pnpm-workspace.yaml   # pnpm workspace 配置
├── tsconfig.json         # 全局 TS 配置，定义路径映射
├── packages/
│   ├── shared/           # 公共类型、工具函数、常量
│   ├── server/           # 后端服务 (Node.js/Python等)
│   ├── web/              # Web 前端 (React/Vue等)
│   └── app/              # 移动端 (React Native/Flutter等)
└── docs/                 # 项目文档
```

### Server 结构
(待填充详细技术栈结构)

### App 结构
(待填充详细技术栈结构)

### Web 结构
(待填充详细技术栈结构)

---

## 四、AI编码友好设计

### 1. 明确的模块边界
通过 `package.json` 的 `dependencies` 显式声明依赖，帮助 AI 理解模块关系。
例如：`import { User } from '@attendance/shared'` 清晰表明来源。

### 2. 统一的路径映射
使用 TypeScript `paths` 配置，让 AI 在生成代码时使用标准别名，而非脆弱的相对路径（如 `../../shared`）。

### 3. 规范的命名
*   包名统一前缀：`@attendance/*`
*   目录名与包名对应：`packages/server` -> `@attendance/server`

---

## 五、版本管理

### 分支策略：简化版 GitHub Flow

```
main ─────●─────●─────●─────●───→
           \   /       \   /
         feature-A   feature-B
```

**规则：**
- `main` 分支始终保持可运行状态
- 新功能从 `main` 拉 `feature-xxx` 分支
- 完成后合并回 `main`
- 不需要 develop、release 等中间分支（2人团队足够简单）

### 提交规范

```
<类型>(<范围>): <描述>

类型：feat / fix / docs / refactor / test
范围：server / web / app / shared
```

**示例：**
```
feat(server): 添加用户登录API
fix(web): 修复打卡按钮无响应
docs(shared): 更新类型定义文档
refactor(server): 重构考勤服务逻辑
```

### 粒度控制

任务拆分和提交粒度通过 Skill（task-planner）定义流程来保障。
→ 详见 `05-工具配置规范.md`

---

## 六、2人协作方式

### 核心认知：AI编码场景下的分工

```
人的角色：指挥官（决策、审核、验证）
AI的角色：执行者（写代码、生成文件）
```

实际写代码的是AI，人负责指挥AI完成各自负责的功能模块。

### 分工模式：功能垂直切分

```
人A：指挥AI完成"用户模块"（全端）
人B：指挥AI完成"考勤模块"（全端）
```

每个人对自己负责的功能模块全权负责：
- 描述需求给AI
- 审核AI生成的代码
- 验证功能是否正确
- 提交代码

### 命名空间隔离

防止两个AI会话生成的代码互相冲突：

| 维度 | A（用户模块） | B（考勤模块） |
|------|--------------|--------------|
| API路径 | `/api/v1/user/*` | `/api/v1/attendance/*` |
| 数据库表 | `users`, `user_*` | `attendance_*`, `shifts` |
| 类型前缀 | `User*`, `Auth*` | `Attendance*`, `Clock*` |
| 目录 | `*/user/`, `*/auth/` | `*/attendance/`, `*/clock/` |

### AI约束（通过Rules实现）

各自的 `user_rules.md` 声明负责的模块，AI只能操作对应命名空间的文件。

### 工作流程

**第一阶段：共同搭建基础**
- 确定技术栈
- 定义共享类型（common.ts）
- 设计数据库表结构
- 配置Rules/Skills

**第二阶段：并行开发**
- 各自指挥AI完成负责的模块
- 完全并行，无需等待

**第三阶段：集成联调**
- 功能串联
- 联调测试

### 冲突处理

由于命名空间隔离，正常情况下不会冲突。
如果发生冲突（改了共享文件），两人一起解决。
