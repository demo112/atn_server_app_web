---
name: test-driven-development
description: "TDD、测试驱动、先写测试、红绿重构、写测试、单元测试"
type: methodology
optional_for: code-implementation
triggers:
  - TDD
  - 测试驱动
  - 先写测试
  - 红绿重构
related_rules:
  - rules/11-testing
---

# 测试驱动开发 (TDD)

> 来源: [obra/superpowers](https://skills.sh/obra/superpowers/test-driven-development)

先写测试。看它失败。写最小代码让它通过。

**核心原则：如果你没有看到测试失败，你不知道它是否测试了正确的东西。**

---

## 激活方式

### 触发场景

- 实现**新功能**
- 修复**Bug**
- **重构**代码
- **API变更**

### 触发关键词

| 类别 | 关键词 |
|------|--------|
| 核心关键词 | TDD、测试驱动、先写测试 |
| 测试类 | 写测试、单元测试、测试用例 |
| 开发类 | 新功能、实现、开发 |

### 激活确认

> **TDD模式已激活** 🧪
> 
> 我将遵循红-绿-重构循环：
> 1. **红** - 写一个失败的测试
> 2. **绿** - 写最小代码让它通过
> 3. **重构** - 清理代码，保持测试绿色

---

## 铁律

**没有失败测试，不写生产代码**

在测试之前写了代码？删除它。重新开始。

无例外：
- "我已经知道它能工作" - 删除它
- "只是一个小改动" - 删除它
- "我之后会加测试" - 删除它

从测试开始实现。句号。

---

## 红-绿-重构

```
红 → 验证正确失败 → 绿 → 验证通过 → 重构 → 保持绿色 → 下一个
```

### 红 - 写失败测试

写一个最小测试展示应该发生什么。

**好的：**
```typescript
test('重试操作3次后成功', async () => {
  const operation = jest.fn()
    .mockRejectedValueOnce(new Error('fail'))
    .mockRejectedValueOnce(new Error('fail'))
    .mockResolvedValueOnce('success');
  
  const result = await retryOperation(operation);
  expect(result).toBe('success');
  expect(operation).toHaveBeenCalledTimes(3);
});
```
清晰的名称，测试真实行为，一件事。

**坏的：**
```typescript
test('重试工作', async () => {
  const mock = jest.fn()
    .mockRejectedValueOnce(new Error())
    .mockRejectedValueOnce(new Error())
    .mockResolvedValueOnce('success');
  await retryOperation(mock);
  expect(mock).toHaveBeenCalledTimes(3);
});
```
模糊的名称，测试mock而不是代码。

要求：
- 一个断言焦点
- 清晰的失败消息
- 测试行为，而不是实现

### 验证红 - 看它失败

**必须。永不跳过。**

```bash
npm test path/to/test.test.ts
```

确认：
- 测试运行
- 测试失败
- 失败原因正确

测试通过？你在测试已有行为。修复测试。
测试报错？修复错误，重新运行直到它正确失败。

### 绿 - 最小代码

写最简单的代码让测试通过。

不要添加功能，重构其他代码，或"改进"超出测试范围。

### 验证绿 - 看它通过

**必须。**

```bash
npm test path/to/test.test.ts
```

确认：
- 测试通过
- 没有其他测试失败

测试失败？修复代码，不是测试。
其他测试失败？现在修复。

### 重构 - 清理

只在绿色之后：
- 移除重复
- 改进命名
- 提取函数

保持测试绿色。不要添加行为。

### 重复

下一个失败测试用于下一个功能。

---

## 为什么顺序重要

### "我之后写测试来验证它工作"

代码之后写的测试立即通过。立即通过什么都不证明：
- 可能测试是错的
- 可能测试没覆盖边缘情况
- 可能测试在测试实现

先测试强迫你看到测试失败，证明它确实测试了什么。

### "我已经手动测试了所有边缘情况"

手动测试是临时的。你认为你测试了所有东西但是：
- 你忘了边缘情况
- 你不能精确重复
- 没有测试了什么的记录

自动化测试是系统的。它们每次以相同方式运行。

### "删除X小时的工作是浪费"

沉没成本谬误。时间已经过去了。你现在的选择：
- 保留未测试的代码（技术债务）
- 删除并正确做（干净代码）

"浪费"是保留你不能信任的代码。

### "TDD是教条的，务实意味着适应"

TDD就是务实的：
- 比调试更快
- 早期捕获Bug
- 记录行为

"务实"的捷径 = 在生产中调试 = 更慢。

---

## 常见合理化借口

| 借口 | 现实 |
|------|------|
| "太简单不需要测试" | 简单代码也会出问题。测试只需30秒。 |
| "我之后会测试" | 立即通过的测试什么都不证明。 |
| "之后测试达到相同目标" | 之后测试 = "这做了什么？" 先测试 = "这应该做什么？" |
| "已经手动测试了" | 临时 ≠ 系统。没有记录，不能重新运行。 |
| "删除X小时是浪费" | 沉没成本谬误。保留未验证代码是技术债务。 |
| "保留作为参考，先写测试" | 你会适应它。那是之后测试。删除意味着删除。 |
| "需要先探索" | 可以。扔掉探索，从TDD开始。 |
| "测试难 = 设计不清" | 听测试。难测试 = 难使用。 |
| "TDD会拖慢我" | TDD比调试更快。务实 = 先测试。 |
| "手动测试更快" | 手动不能证明边缘情况。每次变更你都要重新测试。 |
| "现有代码没有测试" | 你在改进它。为现有代码添加测试。 |

---

## 红旗 - 停下来重新开始

- 在测试之前写代码
- 测试第一次运行就通过
- 每个测试多个断言
- 测试实现细节
- 跳过验证步骤

所有这些都意味着：删除代码。从TDD重新开始。

---

## 示例：Bug修复

Bug：空邮箱被接受

**红**
```typescript
test('拒绝空邮箱', async () => {
  const result = await submitForm({ email: '' });
  expect(result.error).toBe('邮箱必填');
});
```

**验证红**
```bash
$ npm test
FAIL: expected '邮箱必填', got undefined
```

**绿**
```typescript
function submitForm(data: FormData) {
  if (!data.email?.trim()) {
    return { error: '邮箱必填' };
  }
  // ...
}
```

**验证绿**
```bash
$ npm test
PASS
```

**重构**
如果需要，为多个字段提取验证。

---

## 验证清单

标记工作完成前：
- [ ] 每个功能都有先失败的测试
- [ ] 看到每个测试失败
- [ ] 看到每个测试通过
- [ ] 所有测试仍然通过
- [ ] 代码已重构

不能勾选所有框？你跳过了TDD。重新开始。

---

## 卡住时

| 问题 | 解决方案 |
|------|----------|
| 不知道如何测试 | 写期望的API。先写断言。问你的人类伙伴。 |
| 测试太复杂 | 设计太复杂。简化接口。 |
| 必须mock所有东西 | 代码耦合太紧。使用依赖注入。 |
| 测试设置太大 | 提取帮助函数。仍然复杂？简化设计。 |

---

## 最终规则

生产代码 → 测试存在且先失败

否则 → 不是TDD

**没有人类伙伴的许可，无例外。**
