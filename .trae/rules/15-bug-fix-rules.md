# Bug 修复规范

## 核心原则

> **设计锚定 + 最小改动 + 回归验证** —— 修复前必须理解原设计，修复时只改必须改的，修复后确保不破坏已有功能。

---

## 一、修复前：设计锚定

### 规则 F1: 禁止盲修

**修复任何问题前，必须先读取原设计文档。**

```
修复前必须回答：
1. 原设计是什么？（引用 design.md 具体章节）
2. 当前代码哪里偏离了设计？
3. 修复方案是否符合原设计？
```

### 规则 F2: 文档缺失时的处理

| 情况 | 处理方式 |
|------|----------|
| design.md 存在且完整 | 直接锚定 |
| design.md 存在但过时 | 先更新文档，再修复代码 |
| design.md 不存在 | 先补文档（至少相关章节），再修复代码 |

> **铁律：文档即代码，缺则补，老则更，错则改。**

---

## 二、修复中：范围控制与熵减

### 规则 F3: 最小改动原则

| 允许 ✅ | 禁止 ❌ |
|---------|---------|
| 修复逻辑错误 | 顺便重构代码 |
| 修复边界条件 | 顺便优化性能 |
| 修复类型错误 | 顺便改代码风格 |
| 补充缺失校验 | 增加新功能 |

### 规则 F4: 熵减检查

> **核心问题：修复后代码库是什么样？**

修复前必须回答三个问题：

1. **最小代码**：解决这个问题的最小代码是什么？
2. **代码量变化**：修复后总代码量是增加还是减少？
3. **删除机会**：这次修复能顺便删除什么废弃代码？

**红旗信号**（出现时要警惕）：

| 信号 | 问题 | 正确做法 |
|------|------|----------|
| "保持现有的不动" | 现状偏见 | 该删就删 |
| "增加一层抽象" | 过度设计 | 问：真的需要吗？ |
| "更好的关注点分离" | 更多文件=更多熵 | 简单优于分离 |
| "加个配置项更灵活" | YAGNI | 灵活性不是免费的 |
| "写50行删200行" | ✅ 这是好的 | 净减少是目标 |

**衡量标准**：修复后的代码行数，而不是修复过程的工作量。

### 规则 F5: 禁止改变契约

修复不能改变以下内容（除非问题本身就在这里）：

- API 接口签名
- 数据模型结构
- 业务流程逻辑
- 公共代码（common.*）

如需改变，必须暂停并通知人类决策。

### 规则 F6: 改动范围预警

| 检查项 | 触发条件 | 处理 |
|--------|----------|------|
| 文件数量 | > 3 个文件 | 暂停，确认是否合理 |
| 代码量增加 | 修复后代码更多 | 暂停，解释为什么 |
| 核心逻辑 | 涉及核心业务 | 暂停，人工确认 |
| 公共代码 | 涉及 common.* | 拒绝，需团队沟通 |

---

## 三、修复后：回归验证

### 规则 F7: 必须验证清单

修复完成后必须确认：

- [ ] 原问题已解决（有证据）
- [ ] 原有测试仍通过
- [ ] 代码与 design.md 一致
- [ ] 没有引入新行为
- [ ] 编译通过 `npm run build`

### 规则 F8: 禁止的声明

❌ "应该修好了"
❌ "我很有信心"
❌ "代码改了，应该可以了"

必须有运行结果作为证据。

---

## 四、文档输出

### 规则 F9: 修复记录

每次修复必须在 `docs/bug_fix/` 创建记录文件：

```
docs/bug_fix/{YYYYMMDD}-{问题简述}-fix.md
```

### 规则 F10: 文档同步判断

修复完成后评估是否需要同步到其他文档：

| 情况 | 是否同步 |
|------|----------|
| 发现设计文档有误 | 同步更新 design.md |
| 发现 API 契约有误 | 同步更新 api-contract.md |
| 纯代码 bug，设计无误 | 不需要同步 |

---

## 五、与开发流程的边界

### 识别到越界时

如果修复过程中发现以下情况，应提醒切换到开发 Agent：

- 这不是 bug，是需求变更
- 需要新增功能才能解决
- 需要重新设计才能解决
- 涉及多个模块的架构调整

### 提醒模板

```
⚠️ 发现这个问题可能超出修复范围：
- 原因：{具体原因}
- 建议：切换到开发 Agent，走完整的 6A 流程
- 是否切换？
```
